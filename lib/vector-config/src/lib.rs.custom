use std::{time::Duration, collections::HashMap};

use num_traits::{Bounded, Unsigned, ToPrimitive, Float, Signed};
use serde::{Serialize, Deserialize};
use serde_json::Value;

/// The shape of the field.
/// 
/// This maps similiar to the concept of JSON's data types, where types are generalized and have
/// generalized representations.  This allows us to provide general-but-relevant mappings to core
/// types, such as integers and strings and so on, while providing escape hatches for customized
/// types that may be encoded and decoded via "normal" types but otherwise have specific rules or
/// requirements.
/// 
/// Additionally, the shape of a field can encode some basic properties about the field to which it
/// is attached.  For example, numbers can be bounded on or the lower or upper end, while strings
/// could define a minimum length, or even an allowed pattern via regular expressions.
/// 
/// In this way, they describe a more complete shape of the field than simply the data type alone.
#[derive(Clone)]
pub enum Shape {
    Boolean,
    String(StringShape),
    Number(NumberShape),
    Array(ArrayShape),
    Map(MapShape),
    Composite(Vec<Shape>),
}

#[derive(Clone, Default)]
pub struct StringShape {
    minimum_length: Option<usize>,
    maximum_length: Option<usize>,
    allowed_pattern: Option<&'static str>,
}

#[derive(Clone)]
pub enum NumberShape {
    Unsigned {
	    effective_lower_bound: u128,
	    effective_upper_bound: u128,
    },
    Signed {
	    effective_lower_bound: i128,
	    effective_upper_bound: i128,
    },
    FloatingPoint {
	    effective_lower_bound: f64,
	    effective_upper_bound: f64,
    }
}

#[derive(Clone)]
pub struct ArrayShape {
    element_shape: Box<Shape>,
    minimum_length: Option<usize>,
    maximum_length: Option<usize>,
}

#[derive(Clone)]
pub enum MapShape {
    Fixed(HashMap<&'static str, Shape>),
    Dynamic(Box<Shape>),
}

pub struct Field {
    name: &'static str,
    description: &'static str,
    shape: Shape,
    fields: Vec<Field>,
    metadata: Option<Vec<Metadata>>,
}

impl Field {
    fn new<'de, T: Configurable<'de> + Clone>(
        name: &'static str,
        description: &'static str,
        shape: Shape,
        metadata: Option<Vec<TypedMetadata<T>>>,
    ) -> Self {
        Self {
            name,
            description,
            shape,
            fields: Vec::new(),
            metadata: typed_metadata_to_untyped(metadata),
        }
    }
}

pub enum TypedMetadata<T: Serialize> {
    DefaultValue(T), 
    CustomAttribute(String, String),
}

pub enum Metadata {
    DefaultValue(Value), 
    CustomAttribute(String, String),
}

pub trait Configurable<'de>: Serialize + Deserialize<'de> + Sized 
where
    Self: Clone,
{
    /// Gets the human-readable description of this value, if any.
    ///
    /// For standard types, this will be `None`.  Commonly, custom types would implement this
    /// directly, while fields using standard types would provide a field-specific description that
    /// would be used instead of the default descrption.
    fn description() -> Option<&'static str>;

    /// Gets the shape of this value.
    fn shape() -> Shape;

    /// Gets the metadata for this value.
    fn metadata() -> Option<Vec<TypedMetadata<Self>>>;

	/// The fields for this value, if any.
    fn fields(overrides: Option<Vec<TypedMetadata<Self>>>) -> Option<Vec<Field>>;
}

#[derive(Serialize, Deserialize, Clone)]
struct SinkConfig {
    url: String,
    // default[some_fn_that_returns_a_method]
    batch: BatchConfig,
}

impl<'de> Configurable<'de> for SinkConfig {
    fn description() -> Option<&'static str> {
        Some("config for the XYZ sink")
    }

    fn shape() -> Shape {
        let mut fields = HashMap::new();
        fields.insert("url", <String as Configurable>::shape());
        fields.insert("batch", <BatchConfig as Configurable>::shape());

        Shape::Map(MapShape::Fixed(fields))
    }

    fn metadata() -> Option<Vec<TypedMetadata<Self>>> {
        Some(vec![
            TypedMetadata::DefaultValue(SinkConfig {
                url: String::from("foo"),
                batch: BatchConfig::default(),
            })
        ])
    }

    fn fields(overrides: Option<Vec<TypedMetadata<Self>>>) -> Option<Vec<Field>> {
        let shape = Self::shape();
        let mut field_shapes = match shape {
            Shape::Map(MapShape::Fixed(field_shapes)) => field_shapes.clone(),
            _ => unreachable!("SinkConfig is a fixed-field object and cannot be another shape"),
        };

        let base_metadata = <Self as Configurable>::metadata();
        let merged_metadata = merge_metadata_overrides(base_metadata, overrides);

        let url_shape = field_shapes.remove("url").expect("shape for `url` must exist");
        let url_override_metadata = [
            try_derive_field_default_from_self(&merged_metadata, |default: &Self| {
                default.url.clone()
            }),
        ]
        .into_iter()
        .flatten()
        .collect();

        let batch_shape = field_shapes.remove("batch").expect("shape for `batch` must exist");
        let batch_override_metadata = [
            try_derive_field_default_from_self(&merged_metadata, |default: &Self| {
                default.batch.clone()
            }),
        ]
        .into_iter()
        .flatten()
        .collect();

        Some(vec![Field::new::<String>(
            "url",
            "the endpoint to send requests to",
            url_shape,
            Some(url_override_metadata),
        ),
        Field::new::<BatchConfig>(
            "batch",
            <BatchConfig as Configurable>::description().expect("BatchConfig has no defined description, and an override description was not provided"),
            batch_shape,
            Some(batch_override_metadata),
        )])
    }
}


#[derive(Serialize, Deserialize, Default, Clone)]
struct BatchConfig {
    max_events: u32,
    max_bytes: u32,
    max_timeout: Duration,
}

impl<'de> Configurable<'de> for BatchConfig {
    fn description() -> Option<&'static str> {
        Some("controls batching behavior i.e. maximum batch size, the maximum time before a batch is flushed, etc")
    }

    fn shape() -> Shape {
        let mut fields = HashMap::new();
        fields.insert("max_events", <u32 as Configurable>::shape());
        fields.insert("max_bytes", <u32 as Configurable>::shape());
        fields.insert("max_timeout", <Duration as Configurable>::shape());

        Shape::Map(MapShape::Fixed(fields))
    }

    fn metadata() -> Option<Vec<TypedMetadata<Self>>> {
        Some(vec![
            TypedMetadata::DefaultValue(BatchConfig {
                max_events: 1000,
                max_bytes: 1048576,
                max_timeout: Duration::from_secs(60),
            })
        ])
    }

    fn fields(overrides: Option<Vec<TypedMetadata<Self>>>) -> Option<Vec<Field>> {
        let shape = Self::shape();
        let mut field_shapes = match shape {
            Shape::Map(MapShape::Fixed(field_shapes)) => field_shapes.clone(),
            _ => unreachable!("SinkConfig is a fixed-field object and cannot be another shape"),
        };

        let base_metadata = <Self as Configurable>::metadata();
        let merged_metadata = merge_metadata_overrides(base_metadata, overrides);

        let max_events_shape = field_shapes.remove("max_events").expect("shape for `max_events` must exist");
        let max_events_override_metadata = [
            try_derive_field_default_from_self(&merged_metadata, |default: &Self| {
                default.max_events
            }),
        ]
        .into_iter()
        .flatten()
        .collect();

        let max_bytes_shape = field_shapes.remove("max_bytes").expect("shape for `max_bytes` must exist");
        let max_bytes_override_metadata = [
            try_derive_field_default_from_self(&merged_metadata, |default: &Self| {
                default.max_bytes
            }),
        ]
        .into_iter()
        .flatten()
        .collect();

        let max_timeout_shape = field_shapes.remove("max_timeout").expect("shape for `max_timeout` must exist");
        let max_timeout_override_metadata = [
            try_derive_field_default_from_self(&merged_metadata, |default: &Self| {
                default.max_timeout
            }),
        ]
        .into_iter()
        .flatten()
        .collect();

        Some(vec![Field::new::<u32>(
            "max_events",
            "maximum number of events per batch",
            max_events_shape,
            Some(max_events_override_metadata),
        ),
        Field::new::<u32>(
            "max_bytes",
            "maximum number of bytes per batch",
            max_bytes_shape,
            Some(max_bytes_override_metadata),
        ),
        Field::new::<Duration>(
            "max_timeout",
            "maximum period of time a batch can exist before being forcibly flushed",
            max_timeout_shape,
            Some(max_timeout_override_metadata),
        )])
    }
}

impl<'de> Configurable<'de> for u32 {
    fn description() -> Option<&'static str> { None }

    fn shape() -> Shape {
        Shape::Number(default_unsigned_shape::<u32>())
    }

    fn metadata() -> Option<Vec<TypedMetadata<Self>>> {
        None
    }

    fn fields(overrides: Option<Vec<TypedMetadata<Self>>>) -> Option<Vec<Field>> {
        None
    }
}

impl<'de> Configurable<'de> for String {
    fn description() -> Option<&'static str> { None }

    fn shape() -> Shape {
        Shape::String(StringShape::default())
    }

    fn metadata() -> Option<Vec<TypedMetadata<Self>>> {
        None
    }

    fn fields(overrides: Option<Vec<TypedMetadata<Self>>>) -> Option<Vec<Field>> {
        None
    }
}

impl<'de> Configurable<'de> for Duration {
    fn description() -> Option<&'static str> { None }

    fn shape() -> Shape {
        Shape::Number(default_unsigned_shape::<u64>())
    }

    fn metadata() -> Option<Vec<TypedMetadata<Self>>> {
        None
    }

    fn fields(overrides: Option<Vec<TypedMetadata<Self>>>) -> Option<Vec<Field>> {
        None
    }
}

fn typed_metadata_to_untyped<'de, T: Configurable<'de>>(metadata: Option<Vec<TypedMetadata<T>>>) -> Option<Vec<Metadata>> {
    metadata.map(|metadata| {
        let mut new_metadata = Vec::new();
        for entry in metadata {
            let new_entry = match entry {
                TypedMetadata::DefaultValue(default) => {
                    let new_default = serde_json::to_value(default)
                        .expect("default value should not fail to serialize");
                    Metadata::DefaultValue(new_default)
                },
                TypedMetadata::CustomAttribute(key, value) => Metadata::CustomAttribute(key, value),
            };
            new_metadata.push(new_entry);
        }
        new_metadata
    })
}

fn merge_metadata_overrides<'de, T: Configurable<'de> + Clone>(base: Option<Vec<TypedMetadata<T>>>, overrides: Option<Vec<TypedMetadata<T>>>) -> Option<Vec<TypedMetadata<T>>> {
    None
}

fn try_derive_field_default_from_self<'de, T, F, U>(metadata: &Option<Vec<TypedMetadata<T>>>, f: F) -> Option<TypedMetadata<U>>
where
    T: Configurable<'de> + Clone,
    F: Fn(&T) -> U,
    U: Configurable<'de> + Clone,
{
    metadata.as_ref()
        .and_then(|metadata| {
            for entry in metadata {
                if let TypedMetadata::DefaultValue(default) = entry {
                    let field_default = f(default);
                    return Some(TypedMetadata::DefaultValue(field_default))
                }
            }

            None
        })
}

fn default_unsigned_shape<T: Bounded + Unsigned + ToPrimitive>() -> NumberShape {
    NumberShape::Unsigned {
        effective_lower_bound: T::min_value().to_u128().unwrap(),
        effective_upper_bound: T::max_value().to_u128().unwrap(),
    }
}

fn default_signed_shape<T: Bounded + Signed + ToPrimitive>() -> NumberShape {
    NumberShape::Signed {
        effective_lower_bound: T::min_value().to_i128().unwrap(),
        effective_upper_bound: T::max_value().to_i128().unwrap(),
    }
}

fn default_float_shape<T: Float + ToPrimitive>() -> NumberShape {
    NumberShape::FloatingPoint {
        effective_lower_bound: T::min_value().to_f64().unwrap(),
        effective_upper_bound: T::max_value().to_f64().unwrap(),
    }
}
